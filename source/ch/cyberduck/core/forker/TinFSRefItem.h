/* DO NOT EDIT THIS FILE - it is machine generated */
/* Generated for class glguerin.io.imp.mac.macosx.TinFSRefItem */
/* Generated from TinFSRefItem.java*/

#ifndef _Included_glguerin_io_imp_mac_macosx_TinFSRefItem
#define _Included_glguerin_io_imp_mac_macosx_TinFSRefItem
#include <jni.h>
#ifdef __cplusplus
extern "C" {
#endif

/**
	 A TinFSRefItem is an FSRefItemX for MacOSXForker.
	<p>
	 This class assumes that another class (nominally MacOSXForker) has loaded
	 the necessary JNI library, and made the function-names in it available.
	<p>
	 Some static methods are synchronized.
	 This is done because only some of the underlying OS functions are not thread-safe,
	 or I don't know what their thread-safety is (typically, whether reentrant or not).
	 We use the class's own lock for this thread-safety, so it will block any thread that
	 tries to re-enter one of the thread-unsafe alias functions, or anything else where
	 I was unsure of the ultimate re-entrancy.
	 I assume this is enough.  That is, that I don't have to coordinate thread-safety
	 across processes, or with other libraries, or with other native code.
	 This assumption will be wrong if there's another JNI library that calls the same
	 functions, and doesn't use the same class-lock.  Not much I can do about that, though.
	 @author Gregory Guerin
*/

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    makeRef
 * Signature: ([BLjava/lang/String;[B)I
 */

/**
	 Make the resultFSRef refer to the given file or directory,
	 calling FSMakeFSRefUnicode.
	 Return an OSErr value as the result.
	 None of the items may be null.
	<p>
	 If the targeted item doesn't exist, an error-code is returned.
	 Unlike with an FSSpec, an FSRef can't refer to a non-existent item.
	 The rest of the code in FSRefItem is responsible for handling non-existent targets,
	 so they can be encapsulated with behavior similar to a non-existent FSSpec.
	 will call .
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_makeRef
	(JNIEnv *, jobject, jbyteArray, jstring, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    getRefInfo
 * Signature: ([BI[B[C[B)I
 */

/**
	 Get the FSCatalogInfo for theFSRef.
	 Return an OSErr value as the result.
	 The nameBuf and/or parentFSRef may be null.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_getRefInfo
	(JNIEnv *, jobject, jbyteArray, jint, jbyteArray, jcharArray, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    openRef
 * Signature: ([B[CB[S)I
 */

/**
	 Open the item's named fork, calling FSOpenFork.
	 Return an OSError value as the result.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_openRef
	(JNIEnv *, jobject, jbyteArray, jcharArray, jbyte, jshortArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    resolve
 * Signature: ([BZ[B[B)I
 */

/**
	 This method is synchronized under the class-lock, to prevent re-entrant calls from
	 any other thread in the process from calling the thread-unsafe Alias Mgr functions.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_resolve
	(JNIEnv *, jclass, jbyteArray, jboolean, jbyteArray, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    newAlias
 * Signature: ([B[I)I
 */

/**
	 This method is synchronized under the class-lock, to prevent re-entrant calls from
	 any other thread in the process from calling the thread-unsafe Alias Mgr functions.
	##  newAlias( byte[] fsRef, int[] aliasRef );
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_newAlias
	(JNIEnv *, jclass, jbyteArray, jintArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    createAliasFile
 * Signature: (I[BLjava/lang/String;[B[I)I
 */

/**
	 This method is synchronized under the class-lock, to prevent re-entrant calls from
	 any other thread in the process from calling the thread-unsafe Resource Mgr functions.
	##  createAliasFile( int aliasHandle, byte[] parentFSRef, String name, byte[] resultFSRef, int[] iconInfo );
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_createAliasFile
	(JNIEnv *, jclass, jint, jbyteArray, jstring, jbyteArray, jintArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    createSymlink
 * Signature: (Ljava/lang/String;Ljava/lang/String;)I
 */

/**
	 This method is synchronized under the class-lock, to block re-entrant calls from
	 any other thread in the process.
	##  createSymlink( String originalName, String symlinkName );
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_createSymlink
	(JNIEnv *, jclass, jstring, jstring);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    changed
 * Signature: (IZ[B)I
 */

/**
	 This method is synchronized under the class-lock, to prevent re-entrant calls from
	 any other thread in the process from calling the thread-safety-unknown FNNotify() functions.
	##  changed( int msgValue, boolean specifically, byte[] theFSRef );
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_changed
	(JNIEnv *, jclass, jint, jboolean, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    createRef
 * Signature: ([BLjava/lang/String;Z[B)I
 */

/**
	 Create the file or directory referenced by the FSRef and other args,
	 calling FSCreateDirectoryUnicode() or FSCreateFileUnicode().
	 Return an OSErr value as the result.
	 None of the items may be null.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_createRef
	(JNIEnv *, jobject, jbyteArray, jstring, jboolean, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    setRefInfo
 * Signature: ([BI[B)I
 */

/**
	 Set the FSCatalogInfo for theFSRef, calling FSSetCatalogInfo.
	 Return an OSErr value as the result.
	 Returns OSError.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_setRefInfo
	(JNIEnv *, jobject, jbyteArray, jint, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    deleteRef
 * Signature: ([B)I
 */

/**
	 Delete the file or directory referenced by the FSRef,
	 without resolving any aliases.
	 Return an OSError value as the result.
	 Will call FSDeleteObject.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_deleteRef
	(JNIEnv *, jobject, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    renameRef
 * Signature: ([BLjava/lang/String;[B)I
 */

/**
	 Rename the file or directory referenced by the FSRef,
	 without resolving any aliases,
	 calling FSRenameUnicode.
	 Return an OSErr value as the result.
	 None of the items may be null.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_renameRef
	(JNIEnv *, jobject, jbyteArray, jstring, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    moveRef
 * Signature: ([B[B)I
 */

/**
	 Move the file or directory referenced by the FSRef,
	 without resolving any aliases.
	 Return an OSError value as the result.
	 The destination must reference an existing directory.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_moveRef
	(JNIEnv *, jobject, jbyteArray, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    openIterator
 * Signature: ([BI[I)I
 */

/**
	 Calls FSOpenIterator()
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_openIterator
	(JNIEnv *, jclass, jbyteArray, jint, jintArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    bulkInfo
 * Signature: (II[B[C)I
 */

/**
	 Calls FSGetCatalogInfoBulk() for info on a single item.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_bulkInfo
	(JNIEnv *, jclass, jint, jint, jbyteArray, jcharArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    closeIterator
 * Signature: (I)I
 */

/**
	 Calls FSCloseIterator()
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_closeIterator
	(JNIEnv *, jclass, jint);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    findFolderX
 * Signature: (SIZ[S)S
 */

/**
	 Calls FindFolder().
	 Returns OSError.
*/

JNIEXPORT jshort JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_findFolderX
	(JNIEnv *, jclass, jshort, jint, jboolean, jshortArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    volumeRefX
 * Signature: (SI[C[B)S
 */

/**
	 will call FSGetVolumeInfo().
	 Returns OSError.
*/

JNIEXPORT jshort JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_volumeRefX
	(JNIEnv *, jclass, jshort, jint, jcharArray, jbyteArray);

/*
 * Class:     glguerin_io_imp_mac_macosx_TinFSRefItem
 * Method:    nativeInit
 * Signature: ()I
 */

/**
	 This idempotent method performs all the native-side once-only initialization.
	 It's synchronized on the class-lock so it can't be called re-entrantly from other threads.
	 That shouldn't happen, but one never knows.
*/

JNIEXPORT jint JNICALL Java_glguerin_io_imp_mac_macosx_TinFSRefItem_nativeInit
	(JNIEnv *, jclass);

#ifdef __cplusplus
}
#endif
#endif
